// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using BigMachines;

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS1998

namespace Sandbox
{
    public partial class TinyMachine
    {
        public enum State
        {
        }

        public override ManMachineInterface InterfaceInstance => (ManMachineInterface)(this.interfaceInstance ??= new Interface(this));
        public class Interface : ManMachineInterface<int, Sandbox.TinyMachine.State>
        {
            public Interface(TinyMachine machine) : base(machine) {
                var a = this.Machine;
            }

            // private new TinyMachine Machine => (TinyMachine)((ManMachineInterface)this).Machine;
            public CommandList Command => new((TinyMachine)this.Machine);
            public readonly struct CommandList
            {
                public CommandList(TinyMachine machine) { this.machine = machine; }
                private readonly TestMachine machine;

            }
        }

        protected override async Task<StateResult> InternalRun(StateParameter parameter)
        {
            var state = Unsafe.As<int, Sandbox.TinyMachine.State>(ref this.machineState);
            return state switch
            {
                _ => StateResult.Terminate,
            };
        }

        protected override ChangeStateResult InternalChangeState(int state, bool rerun)
        {
            if (this.machineState == state)
            {
                return ChangeStateResult.Success;
            }

            var current = Unsafe.As<int, Sandbox.TinyMachine.State>(ref this.machineState);
            bool canExit = current switch
            {
                _ => true,
            };

            var next = Unsafe.As<int, Sandbox.TinyMachine.State>(ref state);
            bool canEnter = next switch
            {
                _ => false,
            };

            if (!canExit)
            {
                return ChangeStateResult.UnableToExit;
            }
            else if (!canEnter)
            {
                return ChangeStateResult.UnableToEnter;
            }
            else
            {
                this.MachineState = state;
                if (rerun)
                {
                    this.RequestRerun = true;
                }

                return ChangeStateResult.Success;
            }
        }

        public static void RegisterBM(uint typeId)
        {
            BigMachine<int>.StaticInfo[typeof(Sandbox.TinyMachine.Interface)] = new(typeof(Sandbox.TinyMachine), typeId, false, false, null, null);
            MachineRegistry.Register(new(123, typeof(Sandbox.TinyMachine), typeof(BigMachines.Control.SingleMachineControl<,>)) { });
        }
    }

    public partial class ParentClass
    {

        public partial class TinyMachine2<TData>
        {
            public enum State
            {
            }

            public override ManMachineInterface InterfaceInstance => (ManMachineInterface)(this.interfaceInstance ??= new Interface(this));
            public class Interface : ManMachineInterface<Sandbox.ParentClass.TinyMachine2<TData>.State>
            {
                public Interface(TinyMachine2<TData> machine) : base(machine) {}
                private new TinyMachine2<TData> Machine => (TinyMachine2<TData>)((ManMachineInterface)this).Machine;
                public CommandList Command => new(this.Machine);
                public readonly struct CommandList
                {
                    public CommandList(TinyMachine2<TData> machine) { this.machine = machine; }
                    private readonly TestMachine machine;

                }
            }

            protected override async Task<StateResult> InternalRun(StateParameter parameter)
            {
                var state = Unsafe.As<int, Sandbox.ParentClass.TinyMachine2<TData>.State>(ref this.machineState);
                return state switch
                {
                    _ => StateResult.Terminate,
                };
            }

            protected override ChangeStateResult InternalChangeState(int state, bool rerun)
            {
                if (this.machineState == state)
                {
                    return ChangeStateResult.Success;
                }

                var current = Unsafe.As<int, Sandbox.ParentClass.TinyMachine2<TData>.State>(ref this.machineState);
                bool canExit = current switch
                {
                    _ => true,
                };

                var next = Unsafe.As<int, Sandbox.ParentClass.TinyMachine2<TData>.State>(ref state);
                bool canEnter = next switch
                {
                    _ => false,
                };

                if (!canExit)
                {
                    return ChangeStateResult.UnableToExit;
                }
                else if (!canEnter)
                {
                    return ChangeStateResult.UnableToEnter;
                }
                else
                {
                    this.MachineState = state;
                    if (rerun)
                    {
                        this.RequestRerun = true;
                    }

                    return ChangeStateResult.Success;
                }
            }

        }

        internal static void RegisterBM()
        {
        }
    }
}
